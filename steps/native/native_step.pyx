# distutils: language = c++
"""Common description ob both Python and C++ steps. A step is a part of
Arsa, that fulfils one specific task. There it manipulates the systemgraph in
a specific way.

Steps can have dependencies respectively depend on other steps, the
stepmanager then fulfils this dependencies.
"""

cimport cpass
cimport llvm
cimport test
cimport graph

cdef class SuperStep:
    """Super class for Python and C++ steps. Do not use this class directly.
    """

    def get_dependencies(self):
        """Define all dependencies of the step.

        Returns a list of dependencies (str). This means, that the step
        depends on _all_ of the defined steps. The elements of the list are
        strings, that match with the names returned by get_name().
        """
        return []

    def get_name(self) -> str:
        """Return a unique name of the step. The name is used as ID for the
        step."""
        pass

    def get_description(self):
        """Return a descriptive string, that explains what the pass is doing."""
        pass

    def run(self, graph.PyGraph g):
        """Do the actual action of the pass.

        Arguments:
        g -- the system graph.
        """
        raise Exception("Not implemented.")

class Step(SuperStep):
    """Python representation of a step. This is the superclass for all other
    steps."""

    def __init__(self, config: dict):
        """Initialize a Step.

        Arguments:
        config -- the program config. This is a dict of options. Usally the one
                  generated by argparse.
        """
        self._config = config

    def get_name(self):
        return self.__class__.__name__

    def get_description(self) -> str:
        return self.__doc__

ctypedef enum steps:
    LLVM_STEP,
    TEST0_STEP,
    TEST2_STEP

cdef class NativeStep(SuperStep):
    """Constructs a dummy Python class for a C++ step."""

    # the pointer attribute that holds the C++ object
    cdef cpass.Step* _c_pass

    def __cinit__(self, config: dict, steps step_cls):
        """Constructs an arbitrary C++ step object, that inherits from
        cpass.Step. This has the advantage, that only one Python class is
        necessary to wrap arbitrary C++ steps.

        Arguments:
        config      -- a configuration dict like the one Step.__init__()
                       needs.
        step_cls -- an identifier what specific C++ step the object
                       should wrap.
        """
        # select here what specific step should be constructed
        if step_cls == LLVM_STEP:
            self._c_pass = <cpass.Step*> new llvm.LLVMStep(config)
        # for testing purposes (can not be transferred into seperate file)
        elif step_cls == TEST0_STEP:
            self._c_pass = <cpass.Step*> new test.Test0Step(config)
        elif step_cls == TEST2_STEP:
            self._c_pass = <cpass.Step*> new test.Test2Step(config)
        else:
            raise("Unknown step class")

        if self._c_pass is NULL:
            raise MemoryError()

    def __dealloc__(self):
        """Destroy the C++ object (if any)."""
        if self._c_pass is not NULL:
            del self._c_pass

    def get_dependencies(self):
        # doing this in one line leads to a compiler error
        deps = self._c_pass.get_dependencies()
        return [x.decode('UTF-8') for x in deps]

    def run(self, graph.PyGraph g):
        self._c_pass.run(g._c_graph)

    def get_name(self) -> str:
        return self._c_pass.get_name().decode('UTF-8')

    def get_description(self):
        return self._c_pass.get_description()

def provide_steps(config: dict):
    """Provide a list of all native steps. This also constructs as many
    objects as steps exist.

    Arguments:
    config -- a configuration dict like the one Step.__init__() needs.
    """
    return [NativeStep(config, LLVM_STEP)]

def provide_test_steps(config: dict):
    """Do not use this, only for testing purposes."""
    return [NativeStep(config, TEST0_STEP),
            NativeStep(config, TEST2_STEP)]

