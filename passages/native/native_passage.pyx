# distutils: language = c++
"""Common description ob both Python and C++ passages. A passage is a part of
Arsa, that fulfils one specific task. There it manipulates the systemgraph in
a specific way.

Passages can have dependencies respectively depend on other passages, the
passagemanager then fulfils this dependencies.
"""

cimport cpass
cimport llvm
cimport graph

cdef class SuperPassage:
    """Super class for Python and C++ passages. Do not use this class directly.
    """

    def get_dependencies(self):
        """Define all dependencies of the passage.

        Returns a list of dependencies (str). This means, that the passage
        depends on _all_ of the defined passages. The elements of the list are
        strings, that match with the names returned by get_name().
        """
        return []

    def get_name(self) -> str:
        """Return a unique name of the passage. The name is used as ID for the
        passage."""
        pass

    def get_description(self):
        """Return a descriptive string, that explains what the pass is doing."""
        pass

    def run(self, graph.PyGraph g):
        """Do the actual action of the pass.

        Arguments:
        g -- the system graph.
        """
        raise Exception("Not implemented.")

class Passage(SuperPassage):
    """Python representation of a passage. This is the superclass for all other
    passages."""

    def __init__(self, config: dict):
        """Initialize a Passage.

        Arguments:
        config -- the program config. This is a dict of options. Usally the one
                  generated by argparse.
        """
        self._config = config

    def get_name(self):
        return self.__class__.__name__

    def get_description(self) -> str:
        return self.__doc__

ctypedef enum passages:
    LLVM_PASSAGE

cdef class NativePassage(SuperPassage):
    """Constructs a dummy Python class for a C++ passage."""

    # the pointer attribute that holds the C++ object
    cdef cpass.Passage* _c_pass

    def __cinit__(self, config: dict, passages passage_cls):
        """Constructs an arbitrary C++ passage object, that inherits from
        cpass.Passage. This has the advantage, that only one Python class is
        necessary to wrap arbitrary C++ passages.

        Arguments:
        config      -- a configuration dict like the one Passage.__init__()
                       needs.
        passage_cls -- an identifier what specific C++ passage the object
                       should wrap.
        """
        # select here what specific passage should be constructed
        if passage_cls == LLVM_PASSAGE:
            self._c_pass = <cpass.Passage*> new llvm.LLVMPassage(config)
        else:
            raise("Unknown passage class")

        if self._c_pass is NULL:
            raise MemoryError()

    def __dealloc__(self):
        """Destroy the C++ object (if any)."""
        if self._c_pass is not NULL:
            del self._c_pass

    def get_dependencies(self):
        # doing this in one line leads to a compiler error
        deps = self._c_pass.get_dependencies()
        return [x.decode('UTF-8') for x in deps]

    def run(self, graph.PyGraph g):
        self._c_pass.run(g._c_graph)

    def get_name(self) -> str:
        return self._c_pass.get_name().decode('UTF-8')

    def get_description(self):
        return self._c_pass.get_description()

def provide_passages(config: dict):
    """Provide a list of all native passages. This also constructs as many
    objects as passages exist.

    Arguments:
    config -- a configuration dict like the one Passage.__init__() needs.
    """
    return [NativePassage(config, LLVM_PASSAGE)]
